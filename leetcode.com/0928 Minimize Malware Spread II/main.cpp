#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>

using namespace std;

class Solution {
 private:
  vector<int> ids;
  vector<int> sz;
  int n;
  int g;
  void U(int p, int q) {
    int pid = F(p);
    int qid = F(q);
    if (pid == qid) return;
    --g;
    ids[qid] = pid;
    sz[pid] += sz[qid];
  }

  int F(int x) {
    int id = x;
    while (id != ids[id]) id = ids[id];

    while (ids[x] != id) {
      int t = x;
      x = ids[x];
      ids[t] = id;
    }
    return id;
  }

 public:
  int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    ids.resize(n = g = graph.size());
    sz.resize(n);
    fill(sz.begin(), sz.end(), 1);
    iota(ids.begin(), ids.end(), 0);
    sort(initial.begin(), initial.end());
    vector<bool> v(n);
    for (int x : initial) v[x] = true;
    for (int i = 0; i < n; ++i) {
      if (v[i]) continue;
      for (int j = 0; j < n; ++j) {
        if (v[j]) continue;
        if (graph[i][j]) U(i, j);
      }
    }
    for (int i : initial) {
      for (int j = 0; j < n; ++j) {
        if (v[j]) continue;
        if (graph[i][j] & 1) {
          graph[i][F(j)] |= 2;  // connected to group F(j)
        }
      }
    }
    vector<pair<int, int>> cnts(n);  // g:(cnt, init_node)
    for (int i : initial) {
      for (int j = 0; j < n; ++j) {
        if (graph[i][j] & 2) {
          cnts[j].first++;
          cnts[j].second = i;
        }
      }
    }
    int res = initial[0], mx = 0;
    vector<int> sums(n);
    for (int i = 0; i < n; ++i) {
      if (cnts[i].first == 1) sums[cnts[i].second] += sz[i];
    }
    for (int i : initial) {
      if (mx < sums[i]) {
        res = i;
        mx = sums[i];
      }
    }
    return res;
  }
};

int main(int argc, char const* argv[]) {
  Solution s;
  vector<vector<int>> g = {{1, 1, 0}, {1, 1, 1}, {0, 1, 1}};
  vector<int> i = {0, 1};
  cout << s.minMalwareSpread(g, i) << endl;
  return 0;
}
